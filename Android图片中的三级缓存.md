<font size="5" color="#000000" face="隶书">**Android图片中的三级缓存：**</font>

为避免浪费流量，故提出三级缓存策略，通过**网络、本地、内存**三级缓存图片。


<font size="4" color="#000000" face="隶书">**什么是三级缓存？**</font>

**1.** 网络加载，不优先加载，速度慢，浪费流量；

**2.** 本地加载，次优先加载，速度快；

**3.** 内存缓存，优先加载，速度最快。


<font size="4" color="#000000" face="隶书">**原理：**</font>

**①**首次运行App时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中；

**②**之后运行App时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中的图片。
		
	
<font size="4" color="#000000" face="隶书">**一、Android 图片缓存之内存缓存技术：**</font>


**1. 软引用：只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。**
	
定义：map里面的键是用来放图片地址的，既可以是网络上的图片地址，也可以SDcard上的图片地址，map里面的值里面放的是持有软引用的Bitmap，当然如果你要放Drawable，那也是可以的。
	
**2. 内存缓存技术LruCache：当缓存的图片达到了预先设定的值的时候，那么近期使用次数最少的图片就会被回收掉。**
	
步骤：
	  
**(1)** 先设置缓存图片的最大缓存内存大小，我这里设置为手机内存的1/8,其次,初始化了一个LinkedHashMap集合。
           
` 手机内存的获取方式：int MAXMEMONRY = (int) (Runtime.getRuntime().maxMemory() / 1024);`
      
**(2)**  LruCache里面的键值对分别是URL和对应的图片
      
**(3)** 重写了一个叫做sizeOf的方法，返回的是图片数量。
	  
	  
`LruCache的原理实际上是LinkedHashMap。`
	  
	  
<font size="4" color="#ff0000" face="隶书">**注意：**</font>移除和清除缓存是必须要做的事，因为图片缓存处理不当就会报内存溢出。
		
		
**两者比较：**
	
网上有很多人使用软引用加载图片的多 ，但是现在已经不再推荐使用这种方式了，原因如下：
			
**1.** 因为从 Android 2.3 (API Level 9)开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠。
			
**2.** 另外，Android 3.0 (API Level 11)中，图片的数据会存储在本地的内存当中，因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃。

`用LruCache来缓存图片，当存储Image的大小大于LruCache设定的值，系统自动释放内存。这个类是3.1版本中提供的，如果你是在更早的Android版本中开发，则需要导入android-support-v4的jar包。`
			
			
<font size="4" color="#000000" face="隶书">**二、Android 图片缓存之本地缓存（磁盘缓存DiskLruCache）：**</font>

在初次通过网络获取图片后，我们可以使用MD5加密图片的网络地址来作为图片的名称在本地SD卡中将图片保存起来。
	
DiskLruCache的缓存添加是通过**Editor**完成的，步骤如下：
	
**①将图片url的MD5值作为缓存的key：**
		
Editor表示一个缓存对象的编辑对象，如果这个缓存正在被编辑，那么edit()就会返回null，也就是说， DiskLruCache不允许同时编辑一个缓存对象图片的url不能只为作为key（因为url往往含有乱码），一般都是以图片的url的MD5的值作为key。
		
**②DiskLruCache的可用的Editor对象,利用的Editor获得输入流将文件写入缓存目标地址。**
		
**③通过commit来提交写入操作，如果图片下载的过程发生了异常，那么还可以通过Editor的abort()来回退整个操作。**
	
`DiskLruCache的原理实际上是File。`
	
	
<font size="4" color="#000000" face="隶书">**三、Android 图片缓存之网络缓存：**</font>

网络缓存中主要用到了**AsyncTask**来进行异步数据的加载。
	
简单来说，AsyncTask可以看作是一个对handler和线程池的封装，通常，AsyncTask主要用于数据简单时，handler+thread主要用于数据量多且复杂时，当然这也不是必须的，仁者见仁智者见智。
	
同时，为了避免内存溢出的问题，我们可以在获取网络图片后。对其进行图片压缩。
