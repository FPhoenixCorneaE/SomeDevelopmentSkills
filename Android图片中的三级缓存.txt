Android图片中的三级缓存：

	为避免浪费流量，故提出三级缓存策略，通过网络、本地、内存三级缓存图片。


什么是三级缓存？

    1、网络加载，不优先加载，速度慢，浪费流量；

    2、本地加载，次优先加载，速度快；

    3、内存缓存，优先加载，速度最快。


原理：

    ①首次运行App时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中；

    ②之后运行App时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中的图片。
	
	
	
一、Android 图片缓存之内存缓存技术：


	1.软引用：只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。
	
		定义：map里面的键是用来放图片地址的，既可以是网络上的图片地址，也可以SDcard上的图片地址，
	
	map里面的值里面放的是持有软引用的Bitmap，当然如果你要放Drawable，那也是可以的。
	
	2.内存缓存技术LruCache：当缓存的图片达到了预先设定的值的时候，那么近期使用次数最少的图片就会被回收掉。
	
		步骤：
	  
	  （1）先设置缓存图片的最大缓存内存大小，我这里设置为手机内存的1/8,其次,初始化了一个LinkedHashMap集合。
           
		   手机内存的获取方式：int MAXMEMONRY = (int) (Runtime.getRuntime().maxMemory() / 1024);
      
	  （2）LruCache里面的键值对分别是URL和对应的图片
      
	  （3）重写了一个叫做sizeOf的方法，返回的是图片数量。
	  
	  
		LruCache的原理实际上是LinkedHashMap。
	  
	  
		注意：移除和清除缓存是必须要做的事，因为图片缓存处理不当就会报内存溢出。
		
		
	两者比较：
	
		网上有很多人使用软引用加载图片的多 ，但是现在已经不再推荐使用这种方式了，原因如下：
			
			（1）因为从 Android 2.3 (API Level 9)开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，
			
			这让软引用和弱引用变得不再可靠。
			
			（2）另外，Android 3.0 (API Level 11)中，图片的数据会存储在本地的内存当中，
			
			因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃。
			
			用LruCache来缓存图片，当存储Image的大小大于LruCache设定的值，系统自动释放内存。
			
			这个类是3.1版本中提供的，如果你是在更早的Android版本中开发，则需要导入android-support-v4的jar包。
			
			
二、Android 图片缓存之本地缓存（磁盘缓存DiskLruCache）：

	在初次通过网络获取图片后，我们可以使用MD5加密图片的网络地址来作为图片的名称在本地SD卡中将图片保存起来。
	
	DiskLruCache的缓存添加是通过Editor完成的，步骤如下：
	
		①将图片url的MD5值作为缓存的key：
		
			Editor表示一个缓存对象的编辑对象，如果这个缓存正在被编辑，那么edit()就会返回null，也就是说， 
			
		DiskLruCache不允许同时编辑一个缓存对象图片的url不能只为作为key（因为url往往含有乱码），一般都是
		
		以图片的url的MD5的值作为key。
		
		②DiskLruCache的可用的Editor对象,利用的Editor获得输入流将文件写入缓存目标地址。
		
		③通过commit来提交写入操作，如果图片下载的过程发生了异常，那么还可以通过Editor的abort()来回退整个操作。
	
	DiskLruCache的原理实际上是File。
	
	
三、Android 图片缓存之网络缓存：

	网络缓存中主要用到了AsyncTask来进行异步数据的加载。
	
	简单来说，AsyncTask可以看作是一个对handler和线程池的封装，通常，AsyncTask主要用于数据简单时，
	
	handler+thread主要用于数据量多且复杂时，当然这也不是必须的，仁者见仁智者见智。
	
	同时，为了避免内存溢出的问题，我们可以在获取网络图片后。对其进行图片压缩。
